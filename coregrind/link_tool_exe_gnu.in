#! @PERL@

# This script handles linking the tool executables on GNU,
# statically and at an alternative load address.
#
# Linking statically sidesteps all sorts of complications to do with
# having two copies of the dynamic linker (valgrind's and the
# client's) coexisting in the same process.  The alternative load
# address is needed because Valgrind itself will load the client at
# whatever address it specifies, which is almost invariably the
# default load address.  Hence we can't allow Valgrind itself (viz,
# the tool executable) to be loaded at that address.
#
# Unfortunately there's no standard way to do 'static link at
# alternative address', so these link_tool_exe_*.in scripts handle
# the per-platform hoop-jumping.
#
# What we get passed here is:
#   first arg
#      the alternative load address
#   all the rest of the args
#      the gcc invokation to do the final link, that
#      the build system would have done, left to itself
#
# We just let the script 'die' if something is wrong, rather than do
# proper error reporting.  We don't expect the users to run this 
# directly.  It is only run as part of the build process, with 
# carefully constrained inputs.


use warnings;
use strict;


# expect at least: alt-load-address gcc -o foo bar.o
die "Not enough arguments"
    if (($#ARGV + 1) < 5);

my $ala = $ARGV[0];

# check for plausible-ish alt load address
die "Bogus alt-load address"
    if (length($ala) < 3 || index($ala, "0x") != 0);

# The cc invokation to do the final link
my $cc = $ARGV[1];

# and the 'restargs' are argv[2 ..]

# so, build up the complete command here:
# 'cc' -static -Ttext='ala' 'restargs'

my $cmd="$cc -static -Wl,-Ttext=$ala";

# Add the rest of the parameters
foreach my $n (2 .. $#ARGV) {
   $cmd = "$cmd $ARGV[$n]";
}

#print "link_tool_exe_linux: $cmd\n";


# Execute the command:
my $r = system("$cmd");

if ($r == 0) {
    exit 0;
} else {
    exit 1;
}
